gcc -E hello.c  >>hello.i  //预处理

带#号的都是在处理时处理的,不检查语法

gcc -S hello.i //编译，语法检查, 产生hello.s

gcc -c hello.s //汇编 产生hello.o 二进制件

hello.o还不能直接运行，因为需要调用动态库，即需要连接 

gcc hello.o -o hello //链接 hello是可执行件
==================================================
2015/3/24 日
1.linux 文件系统
	基于日志，用于恢复程序
2.文件系统分类
	磁盘文件系统 ntfs,ext3
	闪存文件系统jffs2,yaffs
	数据库		bfs,winfs
	网络		nfs
	虚拟文件系统	vfs(proc)
	vfs 统一封装了所有的文件系统
3.linux 中的文件类型
	d 目录
	l 链接文件
	b 块设备，如硬盘
	c 字符设备
	socket s 网络设备
	管道 p 把一个程序的出口写到另一个程序的入口
	linux 一切皆文件
4.ls -l 命令显示的结果
	drwxr-xr-x :owner的权限 owner所在的组的权限 其他用户的权限
	 
5.linux 根目录下的文件
	|------/bin 存放系统可执行文件的
	|------/sbin 存放管理员用的可执行文件
	|------/etc 配置文件
	|------/lib 共享库文件
	|------/dev 设备
	|------/tmp 临时文件
	|------/boot 启动
	|------/root root用户目录
	|------/mnt 挂载目录
	|------/opt 优化目录
	|------/usr 用户程序目录
	|------/usr/bin(sbin) 用户的可执行文件目录
	|------/var 系统变量
	|------/proc 虚拟文件系统
	|------/lost+found 用来找回文件
	|------/home 用户目录
6.linux下文件颜色的表示含义
	蓝色：目录
	绿色：可执行文件
	红色: 压缩文件
	浅蓝色:链接文件
	灰色:其它文件
7.命令
	输入ls
	ls-->通过path找ls对应的程序-->基于shell的类库像bash,csh,zshell等执行
	命令 whereis //文件在哪里
8.GNU/linux
	GNU:革奴计划
	GPL LGPL
	www.gnu.org
	GNU下有哪些项目
9.linux 命令练习
	ls -al
	ls *.c //查找.c结尾的文件
	ls ?.c //查找一个字符的c文件
	ls [a-z]* //以a到z开头的文件
	通配符
	管道：Pipe:前面的输出作为后面的输入,输入/输出重定向
	| > <
10.联机帮助man
	官方文档是最可靠的
	ls --help //linux 一般是两杠
	f //向前翻页
	b //向后翻页

==================================================================
2015/3/26 18:12 
1.GCC 的程序编绎过程
	.c源代码-->.i 预编译文件-->.s汇编文件-->.o目录文件--->可执行文件
2.GCC
	-c 只编译不链接，生成目标文件.o
	-S 只编译不汇编，生成汇编代码
	-E 只预处理
	-g 包含调试信息
	-o file 指定目标输出文件
	-Idir 搜索头文件路径
	-Ldir 扩大链接库搜索路径，gcc都会默认优先使用共享程序库　
	-static：仅选用静态程序进行链接,如果一个目录中静态库和动态库同时存在，则仅选用静态库
	-On 优化程序
	-Wall 打开gcc能够提供的，常用的警告信息

	-DMACRO选项
	Exp:
		#ifdef OS_LINUX
			...代码段1
		#else
			...代码段2
		#endif
	-DOS_LINUX选项将会执行代码段1

	
3.生成和使用静态链库
例：ar -rcs libstr.a string.o
也可以使用命令-l 库名
库名是不包含函数库和扩展名的字符串
编译main.c 链接静态库libstr.a 的命令
	gcc -o test main.c libstr.a
可以修改为:
	gcc -o test main.c -L./ -lstr
	-L 是指定库函数的路径

4.生成动态链库
gcc -shared -Wl, \ 				#生成静态库
	-soname,libstr.so.l \		#别名
	-o libstr.so string.c		#实际的动态链库文件 

2015/4/2 9:09
============================================================
5.文件描述符
	在Linux 下用文件描述符来描表设备文件和普通文件。文件描述符是一个整型的数据，所有对文件的操作都通过文件描述符来实现。
	文件描述符的范围是 0 ~ OPEN_MAX,因此是一个有效的资源，有使用完毕后要及时释放.
	查看当前文件描述符的最大限制：
		ulimit -n 
	修改文件描述符的限制：
	
mit -SHn 102400 命令来修改该限制，但这个变更只对当前的session有效，当断开连接重新连接后更改就失效了。

如果想永久变更需要修改/etc/security/limits.conf 文件，如下：
vi /etc/security/limits.conf
* hard nofile 102400
* soft nofile 102400

保存退出后重新登录，其最大文件描述符已经被永久更改了。

这只是修改用户级的最大文件描述符限制，也就是说每一个用户登录后执行的程序占用文件描述符的总数不能超过这个限制。

系统级的限制
它是限制所有用户打开文件描述符的总和，可以通过修改内核参数来更改该限制：
sysctl -w fs.file-max=102400

使用sysctl命令更改也是临时的，如果想永久更改需要在/etc/sysctl.conf添加
fs.file-max=102400
保存退出后使用sysctl -p 命令使其生效。

与file-max参数相对应的还有file-nr，这个参数是只读的，可以查看当前文件描述符的使用情况。


直接修改内核参数，无须重启系统。

2015/4/4
===============================================
做实验时发现子进程中获取父进程的id总为1
如果父进程先终止， 而子进程尚在运行中， 这时， 子进程的ppid将被设置为1.(即子进程成为孤儿进程， 由init进程领养)

６.linux下的进程通信的方法：
	半双工管道，FIFO(命名管道),消息队列，信号量，共享内存
